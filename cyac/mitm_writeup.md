# crypto/mitm
Challenge:
```py
n = 15447208482307123413955682657878205626183302597786151639802362911306127953854433286036582051755341579005808268513601378402198004879485276763732224318604872554209138155876024484206299102584788772487289325996937355911654752562569213287053087040091580741503862818581155298352409869808669988303856191451146181228419136143980421094610943007604543731710904282348876562880463070507368374739846765000833097137527021455409088588111628464679967515547068007729823621867385702878929163222107675724175468492250467705065127578769998548521102456356525113639837127722760550339744406259151764878575329648105832802312462190668070076341
message = 1 << 31 # 32 bit number
e = 65537
ct = pow(message, e, n)
print(f'{ct=}')

# ct=247991726454132251477601832182324568830362514038733602791442829211526715767906042903114988063812969263005255812787531693027463516379093173030420481428480284716883213234533162790462565443212886506198308025403510587922748767720753485339549143930857576845911734564386572812805134252300204903255361781404475262937555114341379436444185800512419859510163178595037718397777372263321233882691117021862289039986818923445504337790497036094073812433279511499063908355203711032197435630786492558893639517100996499225055057335090771206382804915664589997600070335644046357442094659424659132635409159768331767907616311062167120425
```

## Solve Process
`n` is over 2000 bits long, so this is probably not going to be very easy to brute. Additionally, we aren't given anything with which to work with, since this is an entirely standard implementation of RSA. Unfortunately, bruting a 32 bit number or a 2000 bit number both aren't feasible, so it seems doomed. 

Fortunately, the name of the challenge is more than a simple clue. mitm implies a meet-in-the-middle attack to shrink the search space from a 32 bit message to a 16 bit message. 

The crux of a meet-in-the-middle attack is that the average 32-bit number $m$ can be factored into $a \cdot b$ for approximately 16-bit $a,b$. RSA gives $m^e = c \mod n$, so if $m$ can be thusly factorized, then we also have $a^eb^e = c \mod n$ or $ca^{-e} = b^e \mod n$. We assume that $b$ is about 16 bits, so we'll search all 16-bit integers for valid $a,b$. I decided to create a dictionary that maps $b^e\mod n$ to $b$ for all possible values. Then, I would compute $ca^{-e}$ for all 16-bit $a$ and hope that one of those values is in the dictionary.

So I had this:
```py
from Crypto.Util.number import *
n = 15447208482307123413955682657878205626183302597786151639802362911306127953854433286036582051755341579005808268513601378402198004879485276763732224318604872554209138155876024484206299102584788772487289325996937355911654752562569213287053087040091580741503862818581155298352409869808669988303856191451146181228419136143980421094610943007604543731710904282348876562880463070507368374739846765000833097137527021455409088588111628464679967515547068007729823621867385702878929163222107675724175468492250467705065127578769998548521102456356525113639837127722760550339744406259151764878575329648105832802312462190668070076341

ct=247991726454132251477601832182324568830362514038733602791442829211526715767906042903114988063812969263005255812787531693027463516379093173030420481428480284716883213234533162790462565443212886506198308025403510587922748767720753485339549143930857576845911734564386572812805134252300204903255361781404475262937555114341379436444185800512419859510163178595037718397777372263321233882691117021862289039986818923445504337790497036094073812433279511499063908355203711032197435630786492558893639517100996499225055057335090771206382804915664589997600070335644046357442094659424659132635409159768331767907616311062167120425

e = 65537

d = {}
for i in range(1<<15, 1<<16):
    d[pow(i,e,n)] = i

for i in range(1<<15, 1<<16):
    k = (ct * pow(i,-e,n)) % n
    if k in d:
        m = i * d[k]
        print('m = ', m)
```

Unfortunately, this output literally nothing. Why? Well, I wasn't too sure. But the idea seemed correct, so I kept staring at my solve script for around 15 minutes. I kind of wanted to give up or ask for help, since this seemed correct, but I decided to keep playing with it for a bit. The only feasible thing that could be wrong was that my ranges weren't correct, so I expanded them. Running the script again with my updated range gave me the flag of `593286738`. This isn't a flag. This is just a 32-bit number. I tried to hit it with the `long_to_bytes(593286738).decode()`, but instead this gave me a decode error. But surely my solve script was correct, since it did output an integer, and it should have been the right number.

At this point, it was already 8 PM, and Cyber Academy was drawing to a close. As I putting my stuff away, I described my progress, and it turns out everything was right, I just. Didn't need to decode the integer. I assumed it had to be a string, since a flag that's just an integer is quite boring, and you can still make an interesting flag with 4 letters. But, whatever. I ended up submitting `cyber{593286738}` to get the solve.

## Solve Script
```py
from Crypto.Util.number import *
n = 15447208482307123413955682657878205626183302597786151639802362911306127953854433286036582051755341579005808268513601378402198004879485276763732224318604872554209138155876024484206299102584788772487289325996937355911654752562569213287053087040091580741503862818581155298352409869808669988303856191451146181228419136143980421094610943007604543731710904282348876562880463070507368374739846765000833097137527021455409088588111628464679967515547068007729823621867385702878929163222107675724175468492250467705065127578769998548521102456356525113639837127722760550339744406259151764878575329648105832802312462190668070076341

ct=247991726454132251477601832182324568830362514038733602791442829211526715767906042903114988063812969263005255812787531693027463516379093173030420481428480284716883213234533162790462565443212886506198308025403510587922748767720753485339549143930857576845911734564386572812805134252300204903255361781404475262937555114341379436444185800512419859510163178595037718397777372263321233882691117021862289039986818923445504337790497036094073812433279511499063908355203711032197435630786492558893639517100996499225055057335090771206382804915664589997600070335644046357442094659424659132635409159768331767907616311062167120425

e = 65537

d = {}
for i in range(1<<14, 1<<16):
    d[pow(i,e,n)] = i

for i in range(1<<14, 1<<16):
    k = (ct * pow(i,-e,n)) % n
    if k in d:
        m = i * d[k]
        print('m = ', m)
```

